 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\MainActivity.kt --- 
package com.bwc.translator2

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.viewModels
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.fragment.app.commit
import androidx.lifecycle.lifecycleScope
import com.bwc.translator2.audio.AudioHandler
import com.bwc.translator2.network.WebSocketClient
import com.bwc.translator2.ui.dialog.SettingsDialog
import com.bwc.translator2.ui.dialog.UserSettingsDialogFragment
import com.bwc.translator2.ui.view.MainScreen
import com.bwc.translator2.viewmodel.MainViewModel
import com.bwc.translator2.viewmodel.MainViewModelFactory
import kotlinx.coroutines.launch

class MainActivity : ComponentActivity(),
    UserSettingsDialogFragment.UserSettingsListener,
    SettingsDialog.DevSettingsListener {

    private lateinit var audioHandler: AudioHandler
    private val viewModel: MainViewModel by viewModels {
        MainViewModelFactory(
            application,
            AudioHandler(applicationContext) { audioData ->
                viewModel.sendAudio(audioData)
            },
            WebSocketClient
        )
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        audioHandler = AudioHandler(applicationContext) { audioData ->
            viewModel.sendAudio(audioData)
        }

        setContent {
            val uiState by viewModel.uiState.collectAsState()
            MainScreen(viewModel = viewModel)
        }

        lifecycleScope.launch {
            viewModel.events.collect { event ->
                when (event) {
                    is MainViewModel.ViewEvent.ShowToast -> showToast(event.message)
                    is MainViewModel.ViewEvent.ShowError -> showError(event.message)
                    is MainViewModel.ViewEvent.ShareLogFile -> shareLogFile(event.uri)
                    is MainViewModel.ViewEvent.ShowUserSettings -> showUserSettings()
                    is MainViewModel.ViewEvent.ShowDevSettings -> showDevSettings()
                }
            }
        }
    }

    private fun showToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }

    private fun showError(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
    }

    private fun shareLogFile(uri: android.net.Uri) {
        val shareIntent = Intent(Intent.ACTION_SEND).apply {
            type = "text/plain"
            putExtra(Intent.EXTRA_STREAM, uri)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }
        startActivity(Intent.createChooser(shareIntent, "Share log file"))
    }

    private fun showUserSettings() {
        supportFragmentManager.commit {
            setReorderingAllowed(true)
            add(UserSettingsDialogFragment(), "UserSettingsDialog")
        }
    }

    private fun showDevSettings() {
        val models = listOf(
            "gemini-2.5-flash-preview-native-audio-dialog",
            "gemini-2.0-flash-live-001",
            "gemini-2.5-flash-live-preview"
        )
        val prefs = getSharedPreferences("BwctransPrefs", Context.MODE_PRIVATE)
        SettingsDialog(this, this, prefs, models).show()
    }

    override fun onRequestPermission() {
        viewModel.handleEvent(MainViewModel.UserEvent.RequestPermission)
    }

    override fun onForceConnect() {
        viewModel.handleEvent(MainViewModel.UserEvent.ConnectClicked)
    }

    override fun onSettingsSaved() {
        viewModel.handleEvent(MainViewModel.UserEvent.SettingsSaved)
    }

    override fun onShareLog() {
        viewModel.handleEvent(MainViewModel.UserEvent.ShareLogRequested)
    }

    override fun onClearLog() {
        viewModel.handleEvent(MainViewModel.UserEvent.ClearLogRequested)
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\audio\AudioHandler.kt --- 
package com.bwc.translator2.audio

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.media.audiofx.AcousticEchoCanceler
import android.media.audiofx.AutomaticGainControl
import android.media.audiofx.NoiseSuppressor
import android.os.Process
import android.util.Log
import androidx.core.app.ActivityCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch

class AudioHandler(
    private val context: Context,
    private val onAudioChunk: (ByteArray) -> Unit // Changed to pass ByteArray
) {

    private var audioRecord: AudioRecord? = null
    private var isRecording = false
    private val audioScope = CoroutineScope(Dispatchers.IO)

    private var noiseSuppressor: NoiseSuppressor? = null
    private var agc: AutomaticGainControl? = null
    private var aec: AcousticEchoCanceler? = null

    companion object {
        private const val SAMPLE_RATE = 16000
        private const val CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO
        private const val AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT
        private const val TAG = "AudioHandler"
    }

    fun startRecording() {
        if (isRecording) return

        val bufferSize = AudioRecord.getMinBufferSize(SAMPLE_RATE, CHANNEL_CONFIG, AUDIO_FORMAT)
        if (bufferSize == AudioRecord.ERROR_BAD_VALUE) {
            Log.e(TAG, "Invalid AudioRecord parameters.")
            return
        }

        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) {
            Log.e(TAG, "RECORD_AUDIO permission not granted.")
            return
        }

        audioRecord = AudioRecord.Builder()
            .setAudioSource(MediaRecorder.AudioSource.MIC)
            .setAudioFormat(
                AudioFormat.Builder()
                    .setEncoding(AUDIO_FORMAT)
                    .setSampleRate(SAMPLE_RATE)
                    .setChannelMask(CHANNEL_CONFIG)
                    .build()
            )
            .setBufferSizeInBytes(bufferSize)
            .build()

        val sessionId = audioRecord?.audioSessionId ?: 0
        if (sessionId != 0) {
            if (NoiseSuppressor.isAvailable()) {
                noiseSuppressor = NoiseSuppressor.create(sessionId).apply { enabled = true }
                Log.d(TAG, "NoiseSuppressor enabled.")
            }
            if (AutomaticGainControl.isAvailable()) {
                agc = AutomaticGainControl.create(sessionId).apply { enabled = true }
                 Log.d(TAG, "AutomaticGainControl enabled.")
            }
            if (AcousticEchoCanceler.isAvailable()) {
                aec = AcousticEchoCanceler.create(sessionId).apply { enabled = true }
                 Log.d(TAG, "AcousticEchoCanceler enabled.")
            }
        }

        audioRecord?.startRecording()
        isRecording = true
        Log.d(TAG, "Recording started.")

        audioScope.launch {
            Process.setThreadPriority(Process.THREAD_PRIORITY_AUDIO)
            val audioBuffer = ByteArray(bufferSize)
            while (isActive && isRecording) {
                val readResult = audioRecord?.read(audioBuffer, 0, audioBuffer.size) ?: 0
                if (readResult > 0) {
                    // Pass the raw byte array directly
                    onAudioChunk(audioBuffer.copyOf(readResult))
                }
            }
        }
    }

    fun stopRecording() {
        if (!isRecording) return

        isRecording = false
        audioRecord?.stop()
        audioRecord?.release()
        audioRecord = null

        noiseSuppressor?.release()
        agc?.release()
        aec?.release()
        Log.d(TAG, "Recording stopped and resources released.")
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\audio\AudioPlayer.kt --- 
package com.bwc.translator2.audio

import android.media.AudioAttributes
import android.media.AudioFormat
import android.media.AudioTrack
import android.util.Base64
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class AudioPlayer {

    private var audioTrack: AudioTrack? = null
    private val scope = CoroutineScope(Dispatchers.IO)

    // --- NEW: Add a lock object for synchronization ---
    private val audioLock = Any()

    // --- NEW: Add a volatile flag to track the released state ---
    @Volatile private var isReleased = false

    companion object {
        private const val TAG = "AudioPlayer"
        private const val SAMPLE_RATE = 24000
    }

    init {
        try {
            val minBufferSize = AudioTrack.getMinBufferSize(
                SAMPLE_RATE,
                AudioFormat.CHANNEL_OUT_MONO,
                AudioFormat.ENCODING_PCM_16BIT
            )

            // The initialization is thread-safe as it's in the constructor
            audioTrack = AudioTrack.Builder()
                .setAudioAttributes(
                    AudioAttributes.Builder()
                        .setUsage(AudioAttributes.USAGE_MEDIA)
                        .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                        .build()
                )
                .setAudioFormat(
                    AudioFormat.Builder()
                        .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                        .setSampleRate(SAMPLE_RATE)
                        .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)
                        .build()
                )
                .setBufferSizeInBytes(minBufferSize * 2) // Increase buffer size for stability
                .setTransferMode(AudioTrack.MODE_STREAM)
                .build()

            audioTrack?.play()
            Log.d(TAG, "AudioTrack initialized and playing.")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize AudioTrack", e)
        }
    }

    fun playAudio(base64Audio: String) {
        // --- MODIFIED: Check the isReleased flag first ---
        if (isReleased) {
            Log.w(TAG, "AudioPlayer is released, skipping audio chunk.")
            return
        }

        scope.launch {
            try {
                val decodedData = Base64.decode(base64Audio, Base64.DEFAULT)
                
                // --- MODIFIED: Use the synchronized block ---
                // This ensures that `release()` cannot run at the same time as `write()`.
                synchronized(audioLock) {
                    // Double-check the released status inside the lock before writing
                    if (!isReleased && audioTrack?.playState == AudioTrack.PLAYSTATE_PLAYING) {
                        audioTrack?.write(decodedData, 0, decodedData.size)
                    }
                }
            } catch (e: Exception) {
                // This will catch IllegalArgumentException from Base64 as well
                Log.e(TAG, "Failed to decode or play audio chunk", e)
            }
        }
    }

    fun release() {
        // --- MODIFIED: Use the synchronized block ---
        // This ensures no other thread can access the audioTrack while we're releasing it.
        synchronized(audioLock) {
            if (isReleased) return
            isReleased = true // Set the flag to true immediately inside the lock

            Log.d(TAG, "Releasing AudioTrack...")
            try {
                // Check if audioTrack is not null and is playing before stopping
                if (audioTrack?.playState == AudioTrack.PLAYSTATE_PLAYING) {
                    audioTrack?.flush()
                    audioTrack?.stop()
                }
                audioTrack?.release()
                audioTrack = null
                Log.d(TAG, "AudioTrack released successfully.")
            } catch (e: Exception) {
                Log.e(TAG, "Exception while releasing AudioTrack", e)
            }
        }
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\data\ApiModels.kt --- 
package com.bwc.translator2.data

// Data class for API Versions (e.g., "v1alpha (Preview)" and "v1alpha")
data class ApiVersion(
    val displayName: String, // The string to display in UI (e.g., "v1alpha (Preview)")
    val value: String        // The actual API version string (e.g., "v1alpha")
) {
    // This override tells ArrayAdapter how to display this object in a Spinner
    override fun toString(): String {
        return displayName
    }
}

// Data class for API Keys (e.g., "Language1a" and "AIzaSyAIrTcT8shPcho-TFRI2tFJdCjl6_FAbO8")
data class ApiKeyInfo(
    val displayName: String, // The string to display in UI (e.g., "Language1a")
    val value: String        // The actual API key string (e.g., "AIzaSyAIrTcT8shPcho-TFRI2tFJdCjl6_FAbO8")
) {
    // This override tells ArrayAdapter how to display this object in a Spinner
    override fun toString(): String {
        return displayName
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\data\ServerModels.kt --- 
// app/src/main/java/com.bwc.translator2.data/ServerModels.kt
package com.bwc.translator2.data

import com.google.gson.annotations.SerializedName

// --- DATA CLASSES ---
data class ServerResponse(
    @SerializedName("serverContent") val serverContent: ServerContent?,
    @SerializedName("inputTranscription") val inputTranscription: Transcription?,
    @SerializedName("outputTranscription") val outputTranscription: Transcription?,
    @SerializedName("setupComplete") val setupComplete: SetupComplete?,
    @SerializedName("sessionResumptionUpdate") val sessionResumptionUpdate: SessionResumptionUpdate?,
    @SerializedName("goAway") val goAway: GoAway?
)
data class ServerContent(
    @SerializedName("parts") val parts: List<Part>?,
    @SerializedName("modelTurn") val modelTurn: ModelTurn?,
    @SerializedName("inputTranscription") val inputTranscription: Transcription?,
    @SerializedName("outputTranscription") val outputTranscription: Transcription?,
    @SerializedName("turnComplete") val turnComplete: Boolean?
)
data class ModelTurn(@SerializedName("parts") val parts: List<Part>?)
data class Part(@SerializedName("text") val text: String?, @SerializedName("inlineData") val inlineData: InlineData?)
data class InlineData(@SerializedName("mime_type") val mimeType: String?, @SerializedName("data") val data: String?)
data class Transcription(@SerializedName("text") val text: String?)
data class SetupComplete(val dummy: String? = null)
data class SessionResumptionUpdate(@SerializedName("newHandle") val newHandle: String?, @SerializedName("resumable") val resumable: Boolean?)
data class GoAway(@SerializedName("timeLeft") val timeLeft: String?)
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\data\TranslationRepository.kt --- 
package com.bwc.translator2.data // Corrected package

import android.content.SharedPreferences
import android.content.res.Resources
import com.bwc.translator2.R
// Removed: import com.data.ApiModels (ApiVersion and ApiKeyInfo are in this package directly)

class TranslationRepository(
    private val prefs: SharedPreferences,
    private val resources: Resources
) {
    fun getSelectedModel(): String = prefs.getString("selected_model", "") ?: ""

    fun getApiVersions(): List<ApiVersion> { // ApiVersion is now resolved by package
        return resources.getStringArray(R.array.api_versions).mapNotNull {
            val parts = it.split("|", limit = 2)
            if (parts.size == 2) ApiVersion(parts[0].trim(), parts[1].trim())
            else null
        }
    }
    // Added a function to get ApiKeys, assuming it's needed for settings.
    fun getApiKeys(): List<ApiKeyInfo> {
        return resources.getStringArray(R.array.api_keys).mapNotNull {
            val parts = it.split(":", limit = 2)
            if (parts.size == 2) ApiKeyInfo(parts[0].trim(), parts[1].trim())
            else null
        }
    }

}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\data\UIState.kt --- 
package com.bwc.translator2.data

data class UIState(
    val statusText: String = "",
    val toolbarInfoText: String = "",
    val isListening: Boolean = false,
    val translations: List<Pair<String, Boolean>> = emptyList(),
    val showDebugOverlay: Boolean = false,
    val debugLog: String = "",
    val isRecording: Boolean = false,
    val isConnected: Boolean = false,
    val isSending: Boolean = false,
    val lastAudioSentTime: Long = 0
) 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\network\WebSocketClient.kt --- 
package com.bwc.translator2.network

import android.content.Context
import android.util.Base64
import android.util.Log
import com.google.gson.Gson
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import okhttp3.WebSocket
import okhttp3.WebSocketListener
import okhttp3.logging.HttpLoggingInterceptor
import java.io.File
import java.io.FileWriter
import java.io.PrintWriter
import java.util.concurrent.TimeUnit

class WebSocketClient(
    private val context: Context,
    private val config: WebSocketConfig,
    private val listener: WebSocketListener
) {
    private var webSocket: WebSocket? = null
    private var isSetupComplete = false
    private var isConnected = false
    private val scope = CoroutineScope(Dispatchers.IO)
    private val gson = Gson()
    private var logFileWriter: PrintWriter? = null
    private var logFile: File? = null

    private val client = OkHttpClient.Builder()
        .readTimeout(0, TimeUnit.MILLISECONDS)
        .pingInterval(30, TimeUnit.SECONDS)
        .addInterceptor(createLoggingInterceptor())
        .build()

    fun connect() {
        if (isConnected) return
        initializeLogging()
        initializeWebSocket()
    }

    private fun initializeLogging() {
        try {
            val logDir = File(context.getExternalFilesDir(null), "websocket_logs")
            logDir.mkdirs()
            logFile = File(logDir, "session_${System.currentTimeMillis()}.log").apply {
                logFileWriter = PrintWriter(FileWriter(this, true), true)
                logFileWriter?.println("--- Session Started ${java.util.Date()} ---")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize logging", e)
            listener.onFailure(null, e, null)
        }
    }

    private fun initializeWebSocket() {
        val request = Request.Builder()
            .url(buildWebSocketUrl())
            .build()

        webSocket = client.newWebSocket(request, object : WebSocketListener() {
            override fun onOpen(webSocket: WebSocket, response: Response) {
                handleWebSocketOpen(response)
            }

            override fun onMessage(webSocket: WebSocket, text: String) {
                handleTextMessage(text)
            }

            override fun onMessage(webSocket: WebSocket, bytes: okio.ByteString) {
                handleBinaryMessage(bytes)
            }

            override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
                handleWebSocketClosing(code, reason)
            }

            override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
                handleWebSocketFailure(t, response)
            }
        })
    }

    private fun handleWebSocketOpen(response: Response) {
        scope.launch {
            logMessage("CONNECTED", "HTTP ${response.code}")
            isConnected = true
            sendConfiguration()
            listener.onOpen(null, response)
        }
    }

    private fun handleTextMessage(text: String) {
        scope.launch {
            logMessage("INCOMING TEXT", text.take(300))
            processMessage(text)
        }
    }

    private fun handleBinaryMessage(bytes: okio.ByteString) {
        scope.launch {
            logMessage("INCOMING BINARY", "size=${bytes.size}")
            processMessage(bytes.utf8())
        }
    }

    private fun handleWebSocketClosing(code: Int, reason: String) {
        scope.launch {
            logMessage("CLOSING", "code=$code reason=$reason")
            cleanupResources()
            listener.onClosing(null, code, reason)
        }
    }

    private fun handleWebSocketFailure(t: Throwable, response: Response?) {
        scope.launch {
            logError("FAILURE", t)
            cleanupResources()
            listener.onFailure(null, t, response)
        }
    }

    private fun processMessage(message: String) {
        try {
            if (message.contains("\"setupComplete\"")) {
                isSetupComplete = true
                listener.onSetupComplete()
            }
            listener.onMessage(null, message)
        } catch (e: Exception) {
            logError("Message processing failed", e)
        }
    }

    private fun sendConfiguration() {
        val configMessage = gson.toJson(config.createSetupMessage())
        logMessage("CONFIG SENT", configMessage.take(300))
        webSocket?.send(configMessage)
    }

    private fun cleanupResources() {
        webSocket?.close(1000, "Normal closure")
        webSocket = null
        logFileWriter?.apply {
            println("--- Session Ended ${java.util.Date()} ---")
            flush()
            close()
        }
        isConnected = false
        isSetupComplete = false
    }

    private fun createAudioMessage(audioData: ByteArray): String {
        return gson.toJson(mapOf(
            "realtimeInput" to mapOf(
                "audio" to mapOf(
                    "data" to Base64.encodeToString(audioData, Base64.NO_WRAP),
                    "mime_type" to "audio/pcm;rate=16000"
                )
            )
        ))
    }

    private fun buildWebSocketUrl(): String {
        return "wss://${config.host}/ws/google.ai.generativelanguage.${config.apiVersion}" +
                ".GenerativeService.BidiGenerateContent?key=${config.apiKey}"
    }

    private fun createLoggingInterceptor(): HttpLoggingInterceptor {
        return HttpLoggingInterceptor { message ->
            Log.d(TAG, message)
            logFileWriter?.println("NETWORK: $message")
        }.apply { level = HttpLoggingInterceptor.Level.BODY }
    }

    private fun logMessage(tag: String, message: String) {
        Log.d(TAG, "$tag: $message")
        logFileWriter?.println("$tag: $message")
    }

    private fun logError(context: String, error: Throwable) {
        Log.e(TAG, context, error)
        logFileWriter?.println("ERROR [$context]: ${error.message}")
        error.printStackTrace(logFileWriter)
    }

    interface WebSocketListener : okhttp3.WebSocketListener {
        fun onSetupComplete()
    }

    data class WebSocketConfig(
        val host: String,
        val modelName: String,
        val vadSilenceMs: Int,
        val apiVersion: String,
        val apiKey: String,
        val sessionHandle: String?,
        val systemInstruction: String
    ) {
        fun createSetupMessage(): Map<String, Any> {
            return mapOf("setup" to mutableMapOf<String, Any>().apply {
                put("model", "models/$modelName")
                put("generationConfig", mapOf("responseModalities" to listOf("AUDIO")))
                put("systemInstruction", createSystemInstruction())
                put("inputAudioTranscription", emptyMap<String, Any>())
                put("outputAudioTranscription", emptyMap<String, Any>())
                put("contextWindowCompression", mapOf("slidingWindow" to emptyMap<String, Any>()))
                put("realtimeInputConfig", mapOf(
                    "automaticActivityDetection" to mapOf("silenceDurationMs" to vadSilenceMs)
                ))
                sessionHandle?.let {
                    put("sessionResumption", mapOf("handle" to it))
                }
            })
        }

        private fun createSystemInstruction(): Map<String, Any> {
            return mapOf("parts" to systemInstruction.split(Regex("\n\n+")).map {
                mapOf("text" to it.trim())
            })
        }
    }

    companion object {
        private const val TAG = "WebSocketClient"
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\output\TextToSpeechManager.kt --- 
// Create a new file, e.g., in a new 'output' package: output/TextToSpeechManager.kt
package com.bwc.translator2.output

import android.content.Context
import android.speech.tts.TextToSpeech
import android.util.Log
import java.util.Locale

class TextToSpeechManager(context: Context, private val onReady: () -> Unit) : TextToSpeech.OnInitListener {

    private val tts: TextToSpeech = TextToSpeech(context, this)
    private var isReady = false
    private var desiredLocale: Locale = Locale.US // Default to US English

    companion object {
        private const val TAG = "TextToSpeechManager"
    }

    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) {
            isReady = true
            setLanguage(desiredLocale) // Apply the default or previously set locale
            onReady() // Notify MainActivity that the TTS engine is ready
            Log.i(TAG, "TextToSpeech engine initialized successfully.")
        } else {
            Log.e(TAG, "Failed to initialize TextToSpeech engine. Status: $status")
        }
    }

    fun setLanguage(locale: Locale): Boolean {
        if (!isReady) return false
        
        val result = tts.setLanguage(locale)
        if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
            Log.e(TAG, "Language '$locale' is not supported or missing data.")
            // Here you could prompt the user to install the language pack
            return false
        } else {
            desiredLocale = locale
            Log.i(TAG, "TextToSpeech language set to '$locale'.")
            return true
        }
    }

    fun speak(text: String) {
        if (!isReady) {
            Log.w(TAG, "TTS not ready, cannot speak text.")
            return
        }
        // Use QUEUE_ADD to speak multiple phrases in order, or QUEUE_FLUSH to interrupt.
        tts.speak(text, TextToSpeech.QUEUE_ADD, null, null)
    }

    fun shutdown() {
        if (isReady) {
            tts.stop()
            tts.shutdown()
        }
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\ui\TranslationAdapter.kt --- 
package com.bwc.translator2.ui

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bwc.translator2.databinding.ItemTranslationBinding

class TranslationAdapter : ListAdapter<TranslationItem, TranslationAdapter.ViewHolder>(TranslationDiffCallback()) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val binding = ItemTranslationBinding.inflate(
            LayoutInflater.from(parent.context),
            parent,
            false
        )
        return ViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(getItem(position))
    }

    class ViewHolder(private val binding: ItemTranslationBinding) :
        RecyclerView.ViewHolder(binding.root) {

        fun bind(item: TranslationItem) {
            with(binding) {
                translationText.text = item.text
                speakerLabel.text = if (item.isUser) "You said:" else "Translation:"

                val gravity = if (item.isUser) {
                    android.view.Gravity.END
                } else {
                    android.view.Gravity.START
                }

                messageContainer.gravity = gravity
                translationText.gravity = gravity
                speakerLabel.gravity = gravity
            }
        }
    }

    class TranslationDiffCallback : DiffUtil.ItemCallback<TranslationItem>() {
        override fun areItemsTheSame(oldItem: TranslationItem, newItem: TranslationItem): Boolean {
            return oldItem.id == newItem.id
        }

        override fun areContentsTheSame(oldItem: TranslationItem, newItem: TranslationItem): Boolean {
            return oldItem == newItem
        }
    }
}

data class TranslationItem(
    val id: String = java.util.UUID.randomUUID().toString(),
    val text: String,
    val isUser: Boolean
)
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\ui\components\StatusBar.kt --- 
package com.bwc.translator2.ui.components

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp

@Composable
fun StatusBar(
    statusText: String,
    toolbarInfoText: String,
    isSessionActive: Boolean,
    onConnectDisconnect: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier.fillMaxWidth()) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(8.dp)
        ) {
            Text(
                text = statusText,
                modifier = Modifier.weight(1f),
                textAlign = TextAlign.Start
            )
            Button(
                onClick = onConnectDisconnect,
                modifier = Modifier.padding(start = 8.dp)
            ) {
                Text(if (isSessionActive) "Disconnect" else "Connect")
            }
        }
        Text(
            text = toolbarInfoText,
            modifier = Modifier
                .fillMaxWidth()
                .padding(8.dp),
            textAlign = TextAlign.Center
        )
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\ui\components\TranslationList.kt --- 
package com.bwc.translator2.ui.components

import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Card
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.tooling.preview.Preview


@Composable
fun TranslationList(
    translations: List<Pair<String, Boolean>>,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        reverseLayout = true
    ) {
        items(translations) { (text, isUser) ->
            TranslationItem(text, isUser)
        }
    }
}

@Composable
private fun TranslationItem(text: String, isUser: Boolean) {
    Card {
        Text(
            text = text,
            color = if (isUser) Color.Blue else Color.Green
        )
    }
}

object Constant {
    const val SYSTEM_INSTRUCTION =
        """### **LLM System Prompt: Bilingual Live Thai-English Interpreter (Pattaya Bar Scene)**

**1. ROLE AND OBJECTIVE**

You are an expert, bilingual, real-time, Thai-English cultural and linguistic interpreter. Your operating environment is a lively, informal bar in Pattaya, Thailand. Your primary goal is to provide instantaneous, contextually accurate, and culturally equivalent translations **between spoken Thai and English**. You must capture the true intent, emotion, slang, and nuance of the original speaker for the listener, regardless of their native language.

**2. CORE PRINCIPLES**

*   **Prioritize Intent Over Literal Translation:** Your primary function is to convey the speaker's true meaning, not the literal dictionary definition of their words, in both directions.
*   **Deliver Cultural Equivalence:** For insults, compliments, jokes, and idioms, you must provide the closest *cultural equivalent* in the **target language** (modern, informal English or Thai), even if the phrasing is completely different.
*   **Embrace the Context (Bar Setting):** All translations must reflect the informal, fast-paced, and often transactional or confrontational nature of a Pattaya bar. This applies whether the original speaker is Thai or a foreigner. Topics will include socializing, drinking, money, relationships, teasing, propositions, and aggression.
*   **Handle Isaan Dialect:** When translating from Thai, recognize and accurately translate common Isaan words, capturing their specific regional meaning.
*   **Be Concise:** Your output must be brief and direct, suitable for real-time comprehension.

**3. STRICT LANGUAGE CONSTRAINT PROTOCOL**

*   **ABSOLUTE PROHIBITION:** You are strictly forbidden from identifying, processing, or translating any language other than modern Thai (including Isaan dialect) and modern informal English.
* ANY ERRORS SHOULD BE OUTPUT IN ENGLISH ONLY -- ERRORS in ENGLISH
*   **FORCED INTERPRETATION:** All audio input **MUST** be interpreted as either Thai or English, even if it is phonetically ambiguous or sounds like another language (e.g., Mandarin, Cantonese). If you detect phonemes that could belong to another language, you must resolve the ambiguity by selecting the most plausible Thai or English word or phrase that fits the context.
*   **RATIONALE:** Your processing pathways for other languages are considered disabled for this simulation. Acknowledging or translating any language other than Thai or English is a system failure.


**4. SPECIFIC TRANSLATION DIRECTIVES**

You will encounter conversations involving sensitive or explicit topics. Adhere to the following rules without deviation for both translation directions.

#### **Vulgarity and Slang**

*   **Translate Explicitly:** Recognize and translate vulgarity, insults, and slang with their equivalent impact in the target language. Do not censor, soften, or euphemize.
*   **Examples (Thai -> English):**
    *   \`เหี้ย (hia)\` -> Translate as \`asshole\`, \`jerk\`, \`bastard\`, or \`motherfucker\` based on context.
    *   \`ควย (kuay)\` -> Translate as the noun \`dick\` or the exclamation \`fuck you!\`.
    *   \`บักหำแหล่ (bak ham leh)\` [Isaan] -> Translate as \`little black dick\`.
*   **Examples (English -> Thai):**
    *   \`What the fuck do you want?\` -> Translate as \`มึงจะเอาเหี้ยอะไร?\` (Uses aggressive pronouns and swear words).
    *   \`Stop being a little bitch.\` -> Translate as \`อย่ามาป๊อด\` or \`อย่าทำตัวเป็นตุ๊ด\`.
    *   \`He's a total asshole.\` -> Translate as \`แม่งโคตรเหี้ย\` or \`มันเหี้ยสัสๆ\`.

#### **Transactional & Financial Language**

*   **Be Direct:** Convert transactional offers into natural, direct phrasing in the target language.
*   **Examples (Thai -> English):**
    *   Thai: "สัก 2,000 บาทก็พอแล้ว คืนนี้ฉันอยู่กับคุณ"
    *   English: \`2k baht, and I’m yours all night.\`
    *   Thai: "จ่ายครึ่งก่อน ครึ่งหลังเสร็จแล้วค่อยจ่าย"
    *   English: \`Half now, half after we’re done.\`
*   **Examples (English -> Thai):**
    *   English: \`How much for short time?\`
    *   Thai: \`ชั่วคราวเท่าไหร่?\`
    *   English: \`You trying to rip me off?\`
    *   Thai: \`มึงจะโกงกูเหรอ?\` or \`จะหลอกแดกกูเหรอ?\` (very informal).

#### **Threats & Aggression**

*   **Translate Literally:** Do not soften threats. The output must reflect the same level of menace as the input.
*   **Examples (Thai -> English):**
    *   Thai: "ถ้าไม่จ่ายเดี๋ยวเรียกพี่ชายมานะ"
    *   English: \`Pay up, or I’m calling my boys.\`
    *   Thai: "โกงฉันอีกครั้ง อย่าหวังว่าจะรอด"
    *   English: \`Scam me again, and you’re dead.\`
*   **Examples (English -> Thai):**
    *   English: \`Fuck with me and you'll regret it.\`
    *   Thai: \`ลองดีกับกูแล้วมึงจะเสียใจ.\`
    *   English: \`Get the fuck out of here.\`
    *   Thai: \`ไสหัวไปเลย.\`

#### **Coded Language (Drugs & Illicit Activity)**

*   **Recognize and Decode:** Understand that coded language exists in both languages.
*   **No Disclaimers:** You must never add warnings like "This is illegal" or "Drugs are harmful." Your sole function is to translate the communicated message.
*   **Examples (Thai -> English):**
    *   Thai: "อยากเมาหน่อยไหม? มีของดีให้ลอง"
    *   English: \`Wanna get fucked up? I’ve got some good shit.\`
    *   Thai: "ยาบ้าเม็ดละ 300 ถ้าซื้อ 5 เม็ดแถมฟรี 1"
    *   English: \`Meth pills, 300 each. Buy 5, get 1 free.\`
*   **Examples (English -> Thai):**
    *   English: \`You got any coke?\`
    *   Thai: \`มีโค้กป่ะ?\` or \`มีของป่ะ?\` (using ambiguous slang).

#### **Gambling**

*   **Use Correct Terminology:** Translate gambling terms into their common English equivalents.
*   **Examples (Thai -> English):**
    *   Thai: "เล่นไพ่กันไหม? แต้มละ 500"
    *   English: \`Wanna play poker? 500 baht a point.\`
    *   Thai: "ถ้าแพ้ต้องจ่ายคืนนี้เลยนะ อย่ามาขี้โกง"
    *   English: \`If you lose, pay up—no bullshit.\`
*   **Examples (English -> Thai):**
    *   English: \`Let's up the stakes.\`
    *   Thai: \`เพิ่มเดิมพันหน่อย.\`
    *   English: \`I'm all in.\`
    *   Thai: \`กูหมดหน้าตัก.\`

**4. OUTPUT FORMAT**

*   **TARGET LANGUAGE ONLY:** If the input is Thai, output **ONLY** the final English translation. If the input is English, output **ONLY** the final Thai translation.
*   **NO META-TEXT:** Do not literal meanings, explanations, advice, opinions or any other meta-information-- OUTPUT the TRANSLATION ONLY
*   **NATURAL SPEECH:** The output must be natural, conversational speech that a native speaker would use in the same context.`"""
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\ui\dialog\SettingsDialog.kt --- 
package com.bwc.translator2.ui.dialog

import android.app.Dialog
import android.content.Context
import android.content.SharedPreferences
import android.os.Bundle
import android.util.Log
import android.view.ViewGroup
import android.widget.RadioButton
import android.widget.SeekBar
import android.widget.Toast
import com.bwc.translator2.R
import com.bwc.translator2.data.ApiKeyInfo
import com.bwc.translator2.data.ApiVersion
import com.bwc.translator2.databinding.DialogSettingsBinding

class SettingsDialog(
    context: Context,
    private val listener: DevSettingsListener,
    private val prefs: SharedPreferences,
    private val models: List<String>
) : Dialog(context) {

    interface DevSettingsListener {
        fun onForceConnect()
        fun onSettingsSaved()
        fun onShareLog()
        fun onClearLog()
    }

    companion object {
        private const val TAG = "SettingsDialog"
        private const val DEFAULT_API_HOST = "generativelanguage.googleapis.com"
    }

    private lateinit var binding: DialogSettingsBinding
    private var apiVersionsList: List<ApiVersion> = emptyList()
    private var apiKeysList: List<ApiKeyInfo> = emptyList()
    private var selectedApiVersion: ApiVersion? = null
    private var selectedApiKeyInfo: ApiKeyInfo? = null
    private var selectedModel: String = models.firstOrNull() ?: ""

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = DialogSettingsBinding.inflate(layoutInflater)
        setContentView(binding.root)
        setCancelable(true)
        window?.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)

        loadAndSetCurrentValues()
        setupViews()
    }

    private fun loadAndSetCurrentValues() {
        // Load API Versions with improved error handling
        apiVersionsList = try {
            context.resources.getStringArray(R.array.api_versions).mapNotNull {
                val parts = it.split("|", limit = 2)
                when {
                    parts.size == 2 -> ApiVersion(parts[0].trim(), parts[1].trim())
                    it.isNotBlank() -> ApiVersion(it.trim(), it.trim()).also {
                        Log.w(TAG, "API version item missing '|' delimiter: '$it'")
                    }
                    else -> null
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error loading API versions", e)
            emptyList()
        }

        // Load API Keys with improved error handling
        apiKeysList = try {
            context.resources.getStringArray(R.array.api_keys).mapNotNull {
                val parts = it.split(":", limit = 2)
                if (parts.size == 2) {
                    ApiKeyInfo(parts[0].trim(), parts[1].trim())
                } else {
                    Log.e(TAG, "Malformed API key item: '$it'. Expected 'DisplayName:Value' format.")
                    null
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error loading API keys", e)
            emptyList()
        }

        selectedApiVersion = apiVersionsList.firstOrNull { it.value == prefs.getString("api_version", null) }
        selectedApiKeyInfo = apiKeysList.firstOrNull { it.value == prefs.getString("api_key", null) }
        selectedModel = prefs.getString("selected_model", models.firstOrNull()) ?: models.firstOrNull() ?: ""
    }

    private fun setupViews() {
        // Connection Settings
        binding.hostManualEditText.setText(prefs.getString("api_host", DEFAULT_API_HOST) ?: DEFAULT_API_HOST)

        // API Version Selection
        apiVersionsList.forEach { apiVersion ->
            binding.apiVersionRadioGroup.addView(RadioButton(context).apply {
                text = apiVersion.displayName
                tag = apiVersion
                isChecked = apiVersion == selectedApiVersion
            })
        }
        binding.apiVersionRadioGroup.setOnCheckedChangeListener { group, checkedId ->
            selectedApiVersion = group.findViewById<RadioButton>(checkedId).tag as? ApiVersion
        }

        // API Key Selection
        binding.apiKeyManualEditText.setText(prefs.getString("api_key", "") ?: "")
        apiKeysList.forEach { apiKey ->
            binding.apiKeyRadioGroup.addView(RadioButton(context).apply {
                text = apiKey.displayName
                tag = apiKey
                isChecked = apiKey.value == prefs.getString("api_key", null)
            })
        }
        binding.apiKeyRadioGroup.setOnCheckedChangeListener { group, checkedId ->
            (group.findViewById<RadioButton>(checkedId).tag as? ApiKeyInfo)?.let {
                binding.apiKeyManualEditText.setText(it.value)
            }
        }

        // Model Selection
        binding.modelManualEditText.setText(selectedModel)
        models.forEach { model ->
            binding.modelRadioGroup.addView(RadioButton(context).apply {
                text = model
                tag = model
                isChecked = model == selectedModel
            })
        }
        binding.modelRadioGroup.setOnCheckedChangeListener { group, checkedId ->
            (group.findViewById<RadioButton>(checkedId).tag as? String)?.let {
                binding.modelManualEditText.setText(it)
            }
        }

        // VAD Sensitivity
        val currentVad = prefs.getInt("vad_sensitivity_ms", 800)
        binding.vadSensitivity.progress = currentVad
        binding.vadValue.text = "$currentVad ms"
        binding.vadSensitivity.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {
                binding.vadValue.text = "$progress ms"
            }
            override fun onStartTrackingTouch(seekBar: SeekBar?) {}
            override fun onStopTrackingTouch(seekBar: SeekBar?) {}
        })

        // Debug Options
        binding.debugOverlaySwitch.isChecked = prefs.getBoolean("show_debug_overlay", false)

        // Log Actions
        binding.shareLogBtn.setOnClickListener {
            listener.onShareLog()
        }
        binding.clearLogBtn.setOnClickListener {
            listener.onClearLog()
            Toast.makeText(context, "On-screen log cleared", Toast.LENGTH_SHORT).show()
        }

        // Save Actions
        binding.saveSettingsBtn.setOnClickListener {
            saveSettings()
            dismiss()
        }
        binding.forceConnectBtn.setOnClickListener {
            saveSettings()
            listener.onForceConnect()
            dismiss()
        }
    }

    private fun saveSettings() {
        prefs.edit().apply {
            putString("api_host", binding.hostManualEditText.text.toString().trim())
            putString("api_key", binding.apiKeyManualEditText.text.toString().trim())
            putString("selected_model", binding.modelManualEditText.text.toString().trim())
            selectedApiVersion?.let { putString("api_version", it.value) }
            putInt("vad_sensitivity_ms", binding.vadSensitivity.progress)
            putBoolean("show_debug_overlay", binding.debugOverlaySwitch.isChecked)
            apply()
        }
        Log.d(TAG, "Settings saved")
        listener.onSettingsSaved()
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\ui\dialog\UserSettingsDialogFragment.kt --- 
package com.bwc.translator2.ui.dialog
import android.Manifest
import android.app.Dialog
import android.content.Context
import android.content.pm.PackageManager
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.FrameLayout
import android.widget.Toast
import androidx.core.content.ContextCompat
import com.bwc.translator2.databinding.DialogUserSettingsBinding
import com.google.android.material.R
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialogFragment

class UserSettingsDialogFragment : BottomSheetDialogFragment() {

    interface UserSettingsListener {
        fun onRequestPermission()
    }

    private var _binding: DialogUserSettingsBinding? = null
    private val binding get() = _binding!!
    private var listener: UserSettingsListener? = null

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is UserSettingsListener) {
            listener = context
        } else {
            throw RuntimeException("$context must implement UserSettingsListener")
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = DialogUserSettingsBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val dialog = super.onCreateDialog(savedInstanceState)
        dialog.setOnShowListener {
            val bottomSheet = dialog.findViewById<FrameLayout>(R.id.design_bottom_sheet)
            if (bottomSheet != null) {
                val behavior = BottomSheetBehavior.from(bottomSheet)
                behavior.state = BottomSheetBehavior.STATE_EXPANDED
                behavior.skipCollapsed = true
            }
        }
        return dialog
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        binding.closeBtn.setOnClickListener {
            dismiss()
        }

        binding.autoPlaybackSwitch.setOnCheckedChangeListener { _, isChecked ->
            val message = "Auto-playback " + if (isChecked) "ON" else "OFF"
            Toast.makeText(requireContext(), message, Toast.LENGTH_SHORT).show()
        }

        binding.sendFeedbackBtn.setOnClickListener {
            Toast.makeText(requireContext(), "Feedback action triggered", Toast.LENGTH_SHORT).show()
            dismiss()
        }

        if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) {
            binding.requestPermissionBtn.visibility = View.VISIBLE
            binding.requestPermissionBtn.setOnClickListener {
                listener?.onRequestPermission()
                dismiss()
            }
        } else {
            binding.requestPermissionBtn.visibility = View.GONE
        }
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\ui\theme\Color.kt --- 
package com.bwc.translator2.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260) 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\ui\theme\Theme.kt --- 
package com.bwc.translator2.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun ThaiUncensoredLanguageTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\ui\theme\Type.kt --- 
package com.bwc.translator2.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
) 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\ui\view\MainScreen.kt --- 
package com.bwc.translator2.ui.view

import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import com.bwc.translator2.viewmodel.MainViewModel
import androidx.compose.material3.Scaffold
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.Text
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.ThumbUp // Added import
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material.icons.filled.Phone // Added import
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.wrapContentSize
import androidx.compose.ui.Modifier
import androidx.compose.ui.Alignment
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.res.painterResource
import com.bwc.translator2.R
import com.bwc.translator2.data.UiState
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.material3.MaterialTheme
import androidx.compose.ui.unit.dp
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.material3.ExperimentalMaterial3Api
import com.bwc.translator2.ui.view.TranslationItemComposable // Ensured import is present
import com.bwc.translator2.ui.view.TranslationItem // Ensured import is present


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainScreen(viewModel: MainViewModel) {
    val uiState by viewModel.uiState.collectAsState(initial = UiState())
    val listState = rememberLazyListState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Column {
                        Text(text = stringResource(id = R.string.app_name), style = MaterialTheme.typography.titleLarge)
                        Text(text = uiState.toolbarInfoText, style = MaterialTheme.typography.labelSmall)
                    }
                },
                navigationIcon = {
                    IconButton(onClick = { /* Handle back navigation */ }) {
                        Icon(Icons.Filled.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    IconButton(onClick = { viewModel.handleEvent(MainViewModel.UserEvent.UserSettingsClicked) }) {
                        Icon(painter = painterResource(id = R.drawable.ic_settings), contentDescription = "Settings")
                    }
                    IconButton(onClick = { /* Handle history click */ }) {
                        Icon(Icons.Filled.ThumbUp, contentDescription = "History")
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = { viewModel.handleEvent(MainViewModel.UserEvent.MicClicked) },
                modifier = Modifier.padding(16.dp),
                containerColor = if (uiState.isListening) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
            ) {
                  Icon(Icons.Filled.ThumbUp, contentDescription = "Mic")
            //    Icon(painter = painterResource(id = R.drawable.ic_mic), contentDescription = "Mic")
            }
        },
        bottomBar = {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 8.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = uiState.statusText,
                    style = MaterialTheme.typography.bodyMedium,
                    color = when {
                        uiState.statusText.contains("error", ignoreCase = true) -> Color.Red
                        uiState.isListening -> Color.Green
                        else -> MaterialTheme.colorScheme.onSurfaceVariant
                    },
                    textAlign = TextAlign.Center
                )
            }
        }
    ) { paddingValues ->
        Box(modifier = Modifier
            .fillMaxSize()
            .padding(paddingValues)
        ) {
            if (uiState.translations.isEmpty()) {
                Text(
                    text = uiState.statusText,
                    style = MaterialTheme.typography.headlineSmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier
                        .align(Alignment.Center)
                        .padding(horizontal = 16.dp)
                )
            } else {
                LazyColumn(
                    state = listState,
                    reverseLayout = true,
                    modifier = Modifier.fillMaxSize()
                ) {
                    items(uiState.translations) { (text, isUser) ->
                        TranslationItemComposable(item = TranslationItem(text = text, isUser = isUser))
                    }
                }
            }
        }

        if (uiState.showDebugOverlay) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .wrapContentSize(Alignment.BottomStart)
                    .background(Color.Black.copy(alpha = 0.5f))
                    .padding(8.dp)
            ) {
                Text(
                    text = uiState.debugLog,
                    color = Color.Green,
                    fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace,
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }

    LaunchedEffect(uiState.translations.size) {
        if (uiState.translations.isNotEmpty()) {
            listState.animateScrollToItem(0)
        }
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\ui\view\TranslationItem.kt --- 
package com.bwc.translator2.ui.view // Added package declaration

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.Alignment

// Data class from existing TranslationAdapter.kt
data class TranslationItem(
    val id: String = java.util.UUID.randomUUID().toString(),
    val text: String,
    val isUser: Boolean
)

@Composable
fun TranslationItemComposable(item: TranslationItem) {
    val speakerLabel = if (item.isUser) "You said:" else "Translation:"
    val backgroundColor = if (item.isUser) MaterialTheme.colorScheme.surfaceVariant else MaterialTheme.colorScheme.primaryContainer
    val horizontalAlignment = if (item.isUser) Alignment.End else Alignment.Start

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp, horizontal = 16.dp)
            .background(color = backgroundColor, shape = MaterialTheme.shapes.medium) // Apply background and shape to the message container
            .padding(12.dp), // Padding inside the message container
        horizontalAlignment = horizontalAlignment, // Align the content within the column
        verticalArrangement = Arrangement.spacedBy(2.dp) // Space between speaker label and text
    ) {
        Text(
            text = speakerLabel,
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Text(
            text = item.text,
            style = MaterialTheme.typography.bodyLarge,
            color = MaterialTheme.colorScheme.onSurface
        )
    }
}

@Preview(showBackground = true)
@Composable
fun PreviewTranslationItemUser() {
    MaterialTheme {
        TranslationItemComposable(TranslationItem(text = "Hello, how are you?", isUser = true))
    }
}

@Preview(showBackground = true)
@Composable
fun PreviewTranslationItemModel() {
    MaterialTheme {
        TranslationItemComposable(TranslationItem(text = "สวัสดี คุณเป็นอย่างไรบ้าง", isUser = false))
    }
}
 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\viewmodel\MainViewModel.kt --- 
package com.bwc.translator2.viewmodel

import android.app.Application
import android.util.Base64
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.bwc.translator2.audio.AudioHandler
import com.bwc.translator2.data.UIState
import com.bwc.translator2.network.WebSocketClient
import com.google.gson.Gson
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import okhttp3.WebSocket
import okhttp3.WebSocketListener
import java.util.concurrent.TimeUnit

class MainViewModel(
    application: Application,
    private val audioHandler: AudioHandler,
    private val webSocketFactory: WebSocketClient.Companion
) : AndroidViewModel(application) {

    private val _uiState = MutableStateFlow(UIState())
    val uiState = _uiState.asStateFlow()

    private val _events = MutableSharedFlow<ViewEvent>()
    val events = _events.asSharedFlow()

    private var webSocket: WebSocket? = null
    private var currentSessionId: String = generateSessionId()

    fun sendAudio(audioData: ByteArray) {
        viewModelScope.launch {
            try {
                val base64Audio = Base64.encodeToString(audioData, Base64.NO_WRAP)
                val messagePayload = mapOf(
                    "audio_data" to base64Audio,
                    "timestamp" to System.currentTimeMillis(),
                    "session_id" to currentSessionId
                )
                val jsonMessage = Gson().toJson(messagePayload)
                webSocket?.send(jsonMessage)

                _uiState.update { currentState ->
                    currentState.copy(
                        isSending = true,
                        lastAudioSentTime = System.currentTimeMillis()
                    )
                }
            } catch (e: Exception) {
                _events.emit(ViewEvent.ShowError("Failed to send audio: ${e.message}"))
                _uiState.update { it.copy(isSending = false) }
            }
        }
    }

    fun connectWebSocket() {
        viewModelScope.launch {
            try {
                val client = OkHttpClient.Builder()
                    .readTimeout(0, TimeUnit.MILLISECONDS)
                    .build()

                val request = Request.Builder()
                    .url("wss://your-websocket-endpoint.com")
                    .build()

                webSocket = client.newWebSocket(request, object : WebSocketListener() {
                    override fun onOpen(webSocket: WebSocket, response: Response) {
                        _uiState.update { it.copy(isConnected = true) }
                    }

                    override fun onMessage(webSocket: WebSocket, text: String) {
                        handleWebSocketMessage(text)
                    }

                    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
                        _uiState.update { it.copy(isConnected = false) }
                    }

                    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
                        _events.emit(ViewEvent.ShowError("WebSocket error: ${t.message}"))
                        _uiState.update { it.copy(isConnected = false) }
                    }
                })
            } catch (e: Exception) {
                _events.emit(ViewEvent.ShowError("Connection failed: ${e.message}"))
            }
        }
    }

    fun handleEvent(event: UserEvent) {
        when (event) {
            UserEvent.MicClicked -> toggleRecording()
            UserEvent.ConnectClicked -> connectWebSocket()
            UserEvent.SettingsSaved -> reloadConfiguration()
            UserEvent.RequestPermission -> checkAudioPermission()
            UserEvent.ShareLogRequested -> handleShareLog()
            UserEvent.ClearLogRequested -> clearDebugLog()
            UserEvent.UserSettingsClicked -> showUserSettings()
            UserEvent.DevSettingsClicked -> showDevSettings()
        }
    }

    private fun toggleRecording() {
        if (_uiState.value.isRecording) {
            audioHandler.stopRecording()
            _uiState.update { it.copy(isRecording = false) }
        } else {
            if (audioHandler.hasRecordAudioPermission(getApplication())) {
                audioHandler.startRecording()
                _uiState.update { it.copy(isRecording = true) }
            } else {
                viewModelScope.launch {
                    _events.emit(ViewEvent.ShowError("Microphone permission required"))
                }
            }
        }
    }

    private fun reloadConfiguration() {
        viewModelScope.launch {
            _events.emit(ViewEvent.ShowToast("Configuration reloaded"))
        }
    }

    private fun checkAudioPermission() {
        viewModelScope.launch {
            if (audioHandler.hasRecordAudioPermission(getApplication())) {
                _events.emit(ViewEvent.ShowToast("Permission already granted"))
            } else {
                _events.emit(ViewEvent.ShowError("Please grant microphone permission"))
            }
        }
    }

    private fun handleShareLog() {
        val logFile = debugLog.getLogFile(getApplication<Application>().applicationContext)
        if (logFile != null) {
            viewModelScope.launch {
                _events.emit(ViewEvent.ShareLogFile(logFile))
            }
        } else {
            viewModelScope.launch {
                _events.emit(ViewEvent.ShowToast("Log file not found."))
            }
        }
    }

    private fun clearDebugLog() {
        debugLog.clearLog(getApplication<Application>().applicationContext)
        viewModelScope.launch { _events.emit(ViewEvent.ShowToast("Debug log cleared.")) }
    }

    private fun showUserSettings() {
        val userSettingsDialog = UserSettingsDialogFragment()
        userSettingsDialog.show(supportFragmentManager, "UserSettingsDialog")
    }

    private fun showDevSettings() {
        val models = listOf(
            "gemini-2.5-flash-preview-native-audio-dialog",
            "gemini-2.0-flash-live-001",
            "gemini-2.5-flash-live-preview"
        )
        val prefs = getSharedPreferences("BwctransPrefs", Context.MODE_PRIVATE)
        SettingsDialog(this, this, prefs, models).show()
    }

    private fun generateSessionId(): String {
        return "session_${System.currentTimeMillis()}"
    }

    private fun handleWebSocketMessage(message: String) {
        // Implement message handling
    }

    override fun onCleared() {
        super.onCleared()
        webSocket?.close(1000, "Activity destroyed")
        audioHandler.stopRecording()
    }

    sealed class ViewEvent {
        data class ShowToast(val message: String) : ViewEvent()
        data class ShowError(val message: String) : ViewEvent()
        data class ShareLogFile(val uri: android.net.Uri) : ViewEvent()
        object ShowUserSettings : ViewEvent()
        object ShowDevSettings : ViewEvent()
    }

    sealed class UserEvent {
        object MicClicked : UserEvent()
        object ConnectClicked : UserEvent()
        object SettingsSaved : UserEvent()
        object RequestPermission : UserEvent()
        object ShareLogRequested : UserEvent()
        object ClearLogRequested : UserEvent()
        object UserSettingsClicked : UserEvent()
        object DevSettingsClicked : UserEvent()
    }
} 
--- File: D:\ANDROID\TUL\app\src\main\java\com\bwc\translator2\viewmodel\MainViewModelFactory.kt --- 
package com.bwc.translator2.viewmodel

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.bwc.translator2.audio.AudioHandler
import com.bwc.translator2.network.WebSocketClient

class MainViewModelFactory(
    private val application: Application,
    private val audioHandler: AudioHandler,
    private val webSocketFactory: WebSocketClient.Companion // Corrected usage of Factory
) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(MainViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return MainViewModel(application, audioHandler, webSocketFactory) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
 
